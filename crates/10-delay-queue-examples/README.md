# 异步延迟队列实例 (delay-queue-examples)

本项目从零开始实现一个基于 `tokio` 的异步、内存中的延迟队列。

## 实现原理

延迟队列的核心是“在指定时间后才能处理任务”。本项目的实现思路如下：

1.  **核心数据结构**: 使用 `std::collections::BinaryHeap` (二叉堆) 作为优先队列来存储任务。二叉堆可以高效地（O(log n)）插入任务，并始终能以 O(1) 的时间复杂度找到执行时间最早的任务（即堆顶元素）。

2.  **任务定义**: 创建一个 `Task` 结构体，包含任务的唯一ID、要执行的数据（payload）以及具体的执行时间 `execute_at`。

3.  **并发安全**: 使用 `tokio::sync::Mutex` 来包裹 `BinaryHeap`，允许多个异步任务安全地向队列中添加任务。

4.  **高效唤醒**: 使用 `tokio::sync::Notify` 来实现一个高效的通知机制。当一个新任务被添加到队列时，如果这个新任务的执行时间比当前等待的任务还要早，我们会通知后台的处理任务（worker）需要重新计算等待时间，而不是傻等。如果没有新任务，worker 会睡眠直到下一个任务到期。

5.  **后台处理 (Worker)**: 一个独立的 `tokio` 异步任务作为后台工作者，它循环地检查堆顶的任务，计算需要睡眠的时间，然后等待。时间到了之后，它就取出任务进行“处理”。

## 如何运行

程序启动后，会向延迟队列中添加3个不同延迟的任务。后台任务会按照延迟时间从短到长的顺序依次处理它们。

```bash
cargo run
```
